/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. MyNewGrammar.jj */
/*@egen*//**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */options{  static = true;}PARSER_BEGIN(MyNewGrammar)package pkg;

public class MyNewGrammar/*@bgen(jjtree)*/implements MyNewGrammarTreeConstants/*@egen*/{/*@bgen(jjtree)*/
  protected static JJTMyNewGrammarState jjtree = new JJTMyNewGrammarState();

/*@egen*/
  static int count = 0;
  static MySymbolTable st = new MySymbolTable();
  static SemanticAnalyzer sa = new SemanticAnalyzer();
  static IRGeneration ir = new IRGeneration();	
    public static void main(String args []) throws ParseException  {    MyNewGrammar parser = new MyNewGrammar(System.in);    while (true)    {      System.out.println("Reading from standard input...");      System.out.print("Enter code of Language X :");      try      {		SimpleNode s = parser.one_line();
		s.dump("");
//		System.out.println("Intermediate Code generation: ");
		System.out.println(ir.InterMedCode(s));
		System.out.println("\n");
		ir.assemblyCode();
		System.out.println("\n");
		System.out.println("\n");
		//System.out.println("Declaration checking: ");
		//sa.typeChecking(s);
		
//        switch (MyNewGrammar.one_line())
//        {
//          case 0 : 
//          System.out.println("OK.");
//          break;
//          case 1 : 
//          System.out.println("Goodbye.");
//          break;
//          default : 
//          break;
//        }
      }      catch (Exception e)      {        System.out.println("NOK.");        System.out.println(e.getMessage());        MyNewGrammar.ReInit(System.in);      }      catch (Error e)      {        System.out.println("Oops.");        System.out.println(e.getMessage());        break;      }    }  }}PARSER_END(MyNewGrammar)SKIP :{  " "| "\r"| "\t"| "\n"}TOKEN : /* OPERATORS */{
  < ASSIGNMENT : "=" >| < PLUS : "+" >| < MINUS : "-" >| < MULTIPLY : "*" >| < DIVIDE : "/" >
| < EQUAL : "==" >
| < NOTEQUAL : "!=" >
| < GREATER : ">" >
| < LESS : "<" >
| < GREATEREQ : ">=" >
| < LESSEQ : "<=" >
| < INCREMENT : "++" >
| < DECREMENT : "--" >}

TOKEN : /* BLOCKS AND LABELS */
{
  < BEGIN : "StartProgram" >
| < END : "endProgram" >
| < INITBLOCK : "initializationBlock:" >
| < CODEBLOCK : "codeBlock:" >
}
TOKEN :{
  < OUTPUT : "outString" >
| < IFSTART : "ifStart" >
| < ELSEST : "else" >
| < IFEND : "ifEnd" >
| < LOOPSTART : "forLoop" >
| < LOOPEND : "endLoop" >
| < INTEGER : "int" >
| < CONSTANT : (< DIGIT >)+ >
| < #DIGIT : [ "0"-"9" ] >
| < ID : (< ALPHA >)+ >
| < ALPHA : ["a"-"z"] >
| < LBRACKET : "(" >
| < RBRACKET : ")" >}SimpleNode one_line() :{/*@bgen(jjtree) one_line */
  SimpleNode jjtn000 = new SimpleNode(JJTONE_LINE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) one_line */
  try {
/*@egen*/  xpro() ";"/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void xpro() :{/*@bgen(jjtree) xpro */
  SimpleNode jjtn000 = new SimpleNode(JJTXPRO);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}{/*@bgen(jjtree) xpro */
  try {
/*@egen*/  < BEGIN >
  	blocks()
  < END >/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}
void blocks() :
{/*@bgen(jjtree) blocks */
  SimpleNode jjtn000 = new SimpleNode(JJTBLOCKS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) blocks */
  try {
/*@egen*/
  < INITBLOCK >
  	declarations()
  < CODEBLOCK >
  	statements()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void declarations() :
{/*@bgen(jjtree) declarations */
  SimpleNode jjtn000 = new SimpleNode(JJTDECLARATIONS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) declarations */
  try {
/*@egen*/
  (
    < INTEGER > Variable("int")
    (
      t = < ASSIGNMENT > { jjtn000.value = t.image; jjtn000.setType("ASSIGNMENTOP"); }
       (        < ID > | < CONSTANT >
      )+    )*
  	";"
  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void statements() :
{/*@bgen(jjtree) statements */
  SimpleNode jjtn000 = new SimpleNode(JJTSTATEMENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) statements */
  try {
/*@egen*/
  (
    ifstatement()
  | loopstatement()
  | outputstatement()  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}

void ifstatement() :
{/*@bgen(jjtree) ifstatement */
  SimpleNode jjtn000 = new SimpleNode(JJTIFSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ifstatement */
  try {
/*@egen*/
  < IFSTART >
  comparison()
  expression()
  (    < ELSEST >
  	expression()
  )*
  < IFEND >/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void loopstatement() :
{/*@bgen(jjtree) loopstatement */
  SimpleNode jjtn000 = new SimpleNode(JJTLOOPSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) loopstatement */
  try {
/*@egen*/
  < LOOPSTART >
  
  < ID > < ASSIGNMENT > < CONSTANT >

  comparison()

  < ID > ( < INCREMENT > | < DECREMENT > )+	
  	expression()
  
  < LOOPEND >/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Integral() : {/*@bgen(jjtree) Integral */
  SimpleNode jjtn000 = new SimpleNode(JJTINTEGRAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Integral */
    try {
/*@egen*/    Variable("")
  | < CONSTANT >/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void LHS() : {/*@bgen(jjtree) LHS */
  SimpleNode jjtn000 = new SimpleNode(JJTLHS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) LHS */
  try {
/*@egen*/
  Variable("")/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void RHS() :
{/*@bgen(jjtree) RHS */
  SimpleNode jjtn000 = new SimpleNode(JJTRHS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) RHS */
  try {
/*@egen*/
  Integral()
  (
	(
  	  t = < PLUS > { jjtn000.value = t.image; jjtn000.setType("PLUSOP"); }
  	| t = < MINUS > { jjtn000.value = t.image; jjtn000.setType("MINUSOP"); }
  	| t = < MULTIPLY > { jjtn000.value = t.image; jjtn000.setType("MULTOP"); }
  	| t = < DIVIDE > { jjtn000.value = t.image; jjtn000.setType("DIVIDEOP"); }
  	)+
  Integral()
  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void outputstatement() :
{/*@bgen(jjtree) outputstatement */
  SimpleNode jjtn000 = new SimpleNode(JJTOUTPUTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) outputstatement */
 try {
/*@egen*/
 < OUTPUT > < LBRACKET > < ID > < RBRACKET > ";"/*@bgen(jjtree)*/
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/} 
void expression():
{/*@bgen(jjtree) expression */
  SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) expression */
  try {
/*@egen*/
  LHS()
  < ASSIGNMENT >
  RHS()
  ";"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void comparison():
{/*@bgen(jjtree) comparison */
  SimpleNode jjtn000 = new SimpleNode(JJTCOMPARISON);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) comparison */
  try {
/*@egen*/
  (
    < ID >
  | < CONSTANT >
  )+
	  (
	    < EQUAL >
	  | < NOTEQUAL >
	  | < GREATER >
	  | < LESS >
	  | < GREATEREQ >
	  | < LESSEQ >
	  )+
  (
    < ID >
  | < CONSTANT >
  )/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ 
}

void Variable(String type) :
{/*@bgen(jjtree) Variable */
  SimpleNode jjtn000 = new SimpleNode(JJTVARIABLE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
  String valueType = null;
}
{/*@bgen(jjtree) Variable */
  try {
/*@egen*/
  t = < ID >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    if (type.equals("int"))
    {
      if(st.checkValue("int "+ t.image)) { 
		System.out.println("ERROR ! duplicate found for " + t.image);
		return;
	  }
      jjtn000.value = t.image;
      jjtn000.setType("int");
      st.put(("ID" + count++), "int " + t.image);
    }
    else
    {
      if(!st.checkValue("int " + t.image)) { 
		System.out.println("ERROR ! undeclared variable " + t.image);
		return;
	  }
      jjtn000.value = t.image;       
      valueType = st.fetchType(t.image); //fetching the type
      if (valueType != null)
      {
        //System.out.println("Extracted Types::: " + valueType);
        if (valueType.equals("int"))
        {
          jjtn000.setType("int");
        }
        
      }
    }
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}